Language Reference
==================

Command-Line Parameters
#######################

*xs* can either be called with no arguments to start up the REPL, or
passed one argument: the path of the script to execute.

Syntax
######

Below is the EBNF grammar for *xs*:
::
   char = ..
   digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
   letter = "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z" ;
   ws = " " | "\t" | "\n" | "\r";

   oper = one_or_more_of "|+=!@#$%^&*-_\\/?~<>,:'";
   individual_oper = ("[" | "]" | ".");
   integer = {digit};
   float = integer, ".", integer;
   identifier = {letter}, {digit};
   quote = "`",  identifier;
   boolean = "0b" | "1b";
   null = "0n" | "0N";
   string = "\"", {char}, "\"";
   fn = "(", {expr}, ")";
   infix_fn = "{", {expr}, "}";
   expr = {{ws}, (float | integer | identifier | quote | boolean | null | string | fn | infix_fn)};

A valid identifier is either a letter followed by one or more letters
and numbers or a symbol (``oper`` in the grammar) repeated one or more
times, such as ``%%%`` or ``$``. Note that one is not allowed to
define an operator such as ``%#`` as each of these symbols will be
parsed seperately. ``[``, ``]``, and ``.`` will always be parsed
individually, even if not seperated by whitespace.

Data Types
##########

+--------+----------------------------+---------------------+
| symbol | description                | example             |
+========+============================+=====================+
| \`Z    | 61-bit integer type        | 42                  |
+--------+----------------------------+---------------------+
| \`R    | 64-bit floating point type | 1.235               |
+--------+----------------------------+---------------------+
| \`B    | Boolean type               | 1b                  |
+--------+----------------------------+---------------------+
| \`Q    | Symbol type                | `hello              |
+--------+----------------------------+---------------------+
| \`S    | String type                | "world"             |
+--------+----------------------------+---------------------+
| \`F    | Function type              | (3*2+)              |
+--------+----------------------------+---------------------+
| \`L    | List type                  | [1 2 3]             |
+--------+----------------------------+---------------------+
| \`H    | I/O handle                 | h:open `R "foo.txt" |
+--------+----------------------------+---------------------+
| \`N    | Null type                  | 0n                  |
+--------+----------------------------+---------------------+

Parsing
#######

*xs* is parsed top to bottom, left to right. Each line or expression
is seperated by a semicolon. The following shows the equivalency
between various expressions: ::

   f; g; h -> h g f
   f g; h -> g f h
   a b; c d; -> b a d c

Scoping
#######

*xs* is dynamically scoped instead of lexically scoped. This means
that an evaluated identifier will look for its definition in the
current running context instead of the lexical context: ::

  xs> f:(x)
  xs> (x:5; f).
  0: 5

Take care to not inadvertantly access variables defined in the
caller's scope.

Math
####

``neg`` unary negative
-----------------------
::

   neg {Z | R | L} -> {Z | R | L}

Unary negative of a value, broadcasts across lists.

``+`` addition
---------------
::

  {Z | R | L} + {Z | R | L} -> {Z | R | L}

Add two values together. Broadcasts across lists.

``-`` substraction
-------------------
::

  {Z | R | L} - {Z | R | L} -> {Z | R | L}

Subtract two values. Broadcasts across lists.

``*`` multiplication
---------------------
::

  {Z | R | L} * {Z | R | L} -> {Z | R | L}

Multiply two values. Broadcasts across lists.

``%`` division
---------------

::

  {Z | R | L} % {Z | R | L} -> {Z | R | L}

Divide two values. Broadcasts across lists.

``mod`` modulus
----------------
::

  {Z | R | L} mod {Z | R | L} -> {Z | R | L}

Remainder of two values. Broadcasts across lists.

``**`` power
--------------
::

  {Z | R | L} ** {Z | R | L} -> {Z | R | L}

Power of two values. Broadcasts across lists.

``ln`` natural logarithm
-------------------------
::

  ln {Z | R | L} -> {Z | R | L}

Natural logarithm, broadcasts across lists.

``sin`` sine
-------------
::

  sin {Z | R | L} -> {Z | R | L}

Sin, broadcasts across lists.

``cos`` cosine
---------------
::

  cos {Z | R | L} -> {Z | R | L}

Cosine, broadcasts across lists.

``tan`` tangent
----------------
::

  tan {Z | R | L} -> {Z | R | L}

Tangent, broadcasts across lists.

``sum`` sum of list
--------------------
::

   sum L -> {Z | R}

Finds the sum of a list: ::

  xs> sum til 5
  0: 10

``sums`` partial sums of list
------------------------------
::

   sums L -> L

Returns the partial sums of the list: ::

  xs> sums til 5
  0: [0 1 3 6 10]

``prod`` product of list
-------------------------
::

   prod L -> {Z | R}

Find the product of all elements in a list: ::

   xs> prod 1+til 4
   0: 24

``prods`` partial products of list
-----------------------------------
::

   prods L -> L

``abs`` absolute value
-----------------------
::

   abs {Z | R | L} -> {Z | R | L}

Find the absolute value of a number or list: ::

   xs> prods til 1+til 4
   0: [1 2 6 24]

``ceil`` ceiling
-----------------
::

   ceil {Z | R | L} -> {Z | R | L}

Find the ceiling of a number or list: ::

  xs> ceil 3.2
  0: 4

``floor`` floor
----------------
::

   floor {Z | R | L} -> {Z | R | L}

Find the floor of a number or list: ::

  xs> floor 3.2
  0: 3

Boolean and Conditionals
########################

``==`` equals
--------------
::

   x == y -> B

Test equality between two values.

``<`` less than
----------------
::

   x < y -> B

Return ``1b`` if the first argument is less than the second, otherwise
``0b``.

``>`` greater than
-------------------
::

   x > y -> B

Returns ``1b`` if the first argument is greater than the second,
otherwise ``0b``.

``gq`` greater or equal
------------------------
::

   x > y -> B

Returns ``1b`` if the first argument is greater or equal to the
second, otherwise ``0b``.

``lq`` less or equal
---------------------
::

   x > y -> B

Return ``1b`` if the first argument is less than or equal to the
second, otherwise ``0b``.

``&&`` And
-----------
::

   B && B -> B

Logical and operation.


``||`` Or
----------
::

   B || B -> B

Logical or.


``if`` if expression
---------------------
::

   if cond:B f:F g:F -> {f. | g.}

Evaluate ``f`` if ``cond`` is ``1b``, otherwise evaluates. ``g``.

``cond`` multiple conditional
------------------------------
::

   cond [(cond_a: F) (f: F) (cond_b: F) (g: F) ... (h: F)] -> {f. | g. | h. ...}

Take a list of functions and tests each condition in order, executing
the corresponding function if the condition is true. Note that only
one function is ever executed and that the length of the list given to
``cond`` must be odd. ::

  xs> x:3; cond [(x==0) ("hello") (x==2) ("goodbye") ("world")]
  0: "world"

``every`` tests all true
-------------------------
::

   every {L | B} -> B

Return true if the given boolean is true or if the given list only
contains ``1b``.

``any`` any true
-----------------
::

   any {L | B} -> B

Return true if the given boolean is true or if the given list
contains at least one ``1b``.

``cmp`` comparison
-------------------
::

   x:* cmp y:* -> {-1 | 0 | 1}

Return ``-1`` if ``x`` is less than ``y``, ``0`` if ``x`` equals
``y``, and ``1`` if ``x`` is greater than ``y``.

Stack Manipulation
##################

``dup`` duplicate element
--------------------------
::

   dup x:* -> x x

Duplicate the top element of the stack.

``swap`` swap elements
-----------------------
::

   swap x:* y:* -> y x

Swap ``x`` and ``y`` on the Stack.

``drop`` drop value
--------------------
::

   drop A -> ()

Discard the top element of the stack.


Function Application
####################

``.`` apply
------------
::

   x:* . -> x.

If ``x`` is a symbol, look up the value and call it if a function,
push onto the stack otherwise. If ``x`` is a function literal, call
``x``, if ``x`` is any other value, simply push ``x`` onto the stack.

``$`` swap and apply
---------------------
::

   f $ x y -> f. y x

Swap ``x`` and ``y`` and then apply ``f``.

Assignment
##########

``:`` set/print
---------------
::

   {Q | L} : x... -> ()

Take a symbol or a list of symbols and bind them to the corresponding
values on the stack: ::

  xs> x:5; x;
  0: 5

  xs> ([`x`y]):3 5; x y;
  1: 5
  0: 3

If given a null instead of a symbol, ``:`` will print out the value to
``stdout``: ::

  xs> 0n:"Hello, World!"
  "Hello, World!"

``~`` peek set/print
--------------------
::

   {Q | L} : x... -> x...

``~`` binds a variable or multiple variables to the local context much
like ``:``, except the value is not popped off the stack: ::

  xs> x+x~5
  0: 10

  xs> ([`x`y])~2 3; x+y+ +.
  0: 10

Likewise, if given a null, ``~`` will print out the value(s) to
``stdout``: ::

  xs> 0n~5
  5
  0: 5

``::`` reassign
---------------
::

   {Q | L} :: x... -> ()

Resassign a variable that already has a definition. Allows the user to
modify variables outside the local scope: ::

  xs> x:5; (x::3); x
  0: 3

Iterators and Accumulators
##########################

``'`` map
---------
::

   f:F ' xs:L -> L

Apply ``f`` to each element of ``xs``: ::

  xs> (2*)'til 3
  0: [0 2 4]

``/`` fold
----------
::

   f:F / xs:L -> *

Fold ``f`` over ``xs``: ::

  xs> +/til 4
  0: 10

``\`` scan
----------
::

   f:F \ xs:L -> *

Fold ``f`` over ``xs``, keeping each partial fold: ::

  xs> +\til 4
  0:[0 1 3 6]

``fix`` fixpoint
----------------
::

   fix f:F x:*-> *

Successively apply ``f`` on ``x`` until two sucessive values equal
each other or one value equals the starting value ``x``: ::

  xs>(x:; x%2) fix 6
  0: 0

``fixes`` partial fixpoints
---------------------------
::

   fixes f:F x:* -> L

Successively apply ``f`` on ``x`` until two sucessive values equal
each other or one value equals the starting value ``x`` while keeping
intermediate values: ::

  xs> (x:; x%2) fixes 6
  0: [6 3 1 0]

``do`` iteration
----------------
::

   x:{F | Z} do f:F -> *

Apply the function ``f`` either ``x`` times if ``x`` is an integer; if
a function, until ``x`` returns ``0b``: ::

  xs> 3 do ("hello")
  2: "hello"
  1: "hello"
  0: "hello"

List  and String
################

``[]`` make list
----------------

``[]`` are special functions that can be used to create a new list: ::

  xs> [[1 2] [3 4]]
  0: [[1 2] [3 4]]

``enlist`` make list
--------------------
::

   n:Z enlist x... -> L

Create a list from the top ``n`` elements from the stack: ::

  xs> 3 enlist 1 2 3
  0:[1 2 3]

``^`` delist
------------
::

   ^ L -> x...

Convert a list into elements on the stack: ::

  xs> ^[1 2 3]
  2: 3
  1: 2
  0: 1

``til`` construct numbered list
-------------------------------
::

   til n:Z -> L

Construct a list between ``0`` and ``n`` (exclusive): ::

  xs> til 4
  [0 1 2 3]

``len`` length of list
----------------------
::

   len xs:{L | S} -> Z

Return the length of ``xs``: ::

  xs> len til 3
  0: 3

  xs> len "abc"
  0: 3

``flip`` flip list
------------------
::

   flip {L | S} -> L

Flip a multidimensional list across its first two dimensions. In the
case of a list with only one dimension (or a string), creates a column
vector: ::

  xs> flip [[1 2] [3 4] [5 6]]
  0: [[1 3 5] [2 4 6]]

  xs> flip til 3
  0: [[0] [1] [2]]

  xs> flip ["abc" "abc" "abc"]
  0: ["aaa" "bbb" "ccc"]

  xs> flip "abc"
  0: ["a" "b" "c"]

``rev`` reverse
---------------
::

   rev {L | S} -> {L | S}

Reverse the given list or string: ::

  xs> rev til 3
  0:[2 1 0]

  xs> rev "abc"
  0:"cba"

``,`` concatenate
-----------------
::

   x:* | y:* -> L

Concatenate two values. If both ``x`` and ``y`` are lists, append
them; if both are atoms, create a list with two elements; if one is a
list and one an atom, cons the value onto the front or back of the
list: ::

  xs> 3,4
  0:[3 4]

  xs> 3,[1 2]
  0: [3 1 2]

  xs>([1 2]),3
  0: [1 2 3]

  xs>([1 2]),[3 4]
  0: [1 2 3 4]

``,,`` cons
-----------
::

   x:* ,, xs:L -> L
   xs:L ,, x:L -> L

places ``x`` at the head or end of ``xs``: ::

  xs> 3,,[1 2]
  0: [3 1 2]

  xs> ([3]),,[1 2]
  0: [[3] 1 2]

  xs> ([1 2]),,3
  0: [1 2 3]
