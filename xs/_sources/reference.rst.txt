Language Reference
==================

Command-Line Parameters
#######################

*xs* can either be called with no arguments to start up the REPL, or
passed one argument: the path of the script to execute.

Syntax
######

Below is the EBNF grammar for *xs*:
::
   char = ..
   digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
   letter = "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z" ;
   ws = " " | "\t" | "\n" | "\r";

   oper = one_or_more_of "|+=!@#$%^&*-_\\/?~<>,:'";
   individual_oper = ("[" | "]" | ".");
   integer = {digit};
   float = integer, ".", integer;
   identifier = {letter}, {digit};
   quote = "`",  identifier;
   boolean = "0b" | "1b";
   null = "0n" | "0N";
   string = "\"", {char}, "\"";
   fn = "(", {expr}, ")";
   infix_fn = "{", {expr}, "}";
   expr = {{ws}, (float | integer | identifier | quote | boolean | null | string | fn | infix_fn)};

A valid identifier is either a letter followed by one or more letters
and numbers or a symbol repeated one or more times, such as ``%%%`` or
``$``. Note that one is not allowed to defined an operator such as
``%#`` as each of these symbols will be parsed seperately. ``[``,
``]``, and ``.`` will always be parsed seperately, even if not
seperated by whitespace.


Data Types
##########

+--------+----------------------------+---------------------+
| symbol | description                | example             |
+========+============================+=====================+
| \`Z    | 61-bit integer type        | 42                  |
+--------+----------------------------+---------------------+
| \`R    | 64-bit floating point type | 1.235               |
+--------+----------------------------+---------------------+
| \`B    | Boolean type               | 1b                  |
+--------+----------------------------+---------------------+
| \`Q    | Symbol type                | `hello              |
+--------+----------------------------+---------------------+
| \`S    | String type                | "world"             |
+--------+----------------------------+---------------------+
| \`F    | Function type              | (3*2+)              |
+--------+----------------------------+---------------------+
| \`L    | List type                  | [1 2 3]             |
+--------+----------------------------+---------------------+
| \`H    | I/O handle                 | h:open `R "foo.txt" |
+--------+----------------------------+---------------------+
| \`N    | Null type                  | 0n                  |
+--------+----------------------------+---------------------+

Parsing
#######

*xs* is parsed top to bottom, left to right. Each line or expression
is seperated by a semicolon. The following shows the equivalency
between various expressions: ::

   f; g; h -> h g f
   f g; h -> g f h
   a b; c d; -> b a d c

Scoping
#######

*xs* is dynamically scoped instead of lexically scoped. This means
that an evaluated identifier will look for its definition in the
current running context instead of the lexical context. Take care to
not inadvertantly access variables defined in the caller's scope.

Math
####

``neg`` unary negative
-----------------------
::

   neg {Z | R | L} -> {Z | R | L}

Unary negative of a value, broadcasts across lists.

``+`` addition
---------------
::

  {Z | R | L} + {Z | R | L} -> {Z | R | L}

Adds two values together. Broadcasts across lists.

``-`` substraction
-------------------
::

  {Z | R | L} - {Z | R | L} -> {Z | R | L}

Subtract two values. Broadcasts across lists.

``*`` multiplication
---------------------
::

  {Z | R | L} * {Z | R | L} -> {Z | R | L}

Multiplies two values. Broadcasts across lists.

``%`` division
---------------

::

  {Z | R | L} % {Z | R | L} -> {Z | R | L}

Divides two values. Broadcasts across lists.

``mod`` modulus
----------------
::

  {Z | R | L} mod {Z | R | L} -> {Z | R | L}

Remainder of two values. Broadcasts across lists.

``**`` power
--------------
::

  {Z | R | L} ** {Z | R | L} -> {Z | R | L}

Power of two values. Broadcasts across lists.

``ln`` natural logarithm
-------------------------
::

  ln {Z | R | L} -> {Z | R | L}

Natural logarithm, broadcasts across lists.

``sin`` sine
-------------
::

  sin {Z | R | L} -> {Z | R | L}

Sin, broadcasts across lists.

``cos`` cosine
---------------
::

  cos {Z | R | L} -> {Z | R | L}

Cosine, broadcasts across lists.

``tan`` tangent
----------------
::

  tan {Z | R | L} -> {Z | R | L}

Tangent, broadcasts across lists.

``sum`` sum of list
--------------------
::

   sum L -> {Z | R}

Finds the sum of a list: ::

  xs> sum til 5
  0: 10

``sums`` partial sums of list
------------------------------
::

   sums L -> L

Returns the partial sums of the list: ::

  xs> sums til 5
  0: [0 1 3 6 10]

``prod`` product of list
-------------------------
::

   prod L -> {Z | R}

Find the product of all elements in a list: ::

   xs> prod 1+til 4
   0: 24

``prods`` partial products of list
-----------------------------------
::

   prods L -> L

``abs`` absolute value
-----------------------
::

   abs {Z | R | L} -> {Z | R | L}

Find the absolute value of a number or list: ::

   xs> prods til 1+til 4
   0: [1 2 6 24]

``ceil`` ceiling
-----------------
::

   ceil {Z | R | L} -> {Z | R | L}

Find the ceiling of a number or list: ::

  xs> ceil 3.2
  0: 4

``floor`` floor
----------------
::

   floor {Z | R | L} -> {Z | R | L}

Find the floor of a number or list: ::

  xs> floor 3.2
  0: 3

Boolean and Conditionals
########################

``==`` equals
--------------
::

   x == y -> B

Tests equality between two values.

``<`` less than
----------------
::

   x < y -> B

Returns ``1b`` if the first argument is less than the second,
otherwise ``0b``.

``>`` greater than
-------------------
::

   x > y -> B

Returns ``1b`` if the first argument is greater than the second,
otherwise ``0b``.

``gq`` greater or equal
------------------------
::

   x > y -> B

Returns ``1b`` if the first argument is greater or equal to the
second, otherwise ``0b``.

``lq`` less or equal
---------------------
::

   x > y -> B

Returns ``1b`` if the first argument is less than or equal to the
second, otherwise ``0b``.

``&&`` And
-----------
::

   B && B -> B

Logical and operation.


``||`` Or
----------
::

   B || B -> B

Logical or.


``if`` if expression
---------------------
::

   if cond:B f:F g:F -> {f. | g.}

Evalues ``f`` if ``cond`` is ``1b``, otherwise evaluates. ``g``.

``cond`` multiple conditional
------------------------------
::

   cond [(cond_a: F) (f: F) (cond_b: F) (g: F) ... (h: F)] -> {f. | g. | h. ...}

Takes a list of functions and tests each condition in order, executing
the corresponding function if the condition is true. Note that only
one function is ever executed and that the length of the list given to
``cond`` must be odd. ::

  xs> x:3; cond [(x==0) ("hello") (x==2) ("goodbye") ("world")]
  0: "world"

``every`` tests all true
-------------------------
::

   every {L | B} -> B

Returns true if the given boolean is true or if the given list only
contains ``1b``.

``any`` any true
-----------------
::

   any {L | B} -> B

Returns true if the given boolean is true or if the given list
contains at least one ``1b``.

``cmp`` comparison
-------------------
::

   x:* cmp y:* -> {-1 | 0 | 1}

Returns ``-1`` if ``x`` is less than ``y``, ``0`` if ``x`` equals
``y``, and ``1`` if ``x`` is greater than ``y``.

Stack Manipulation
##################

``dup`` duplicate element
--------------------------
::

   dup x:* -> x x

Duplicate the top element of the stack.

``swap`` swap elements
-----------------------
::

   swap x:* y:* -> y x

Swap ``x`` and ``y`` on the Stack.

``drop`` drop value
--------------------
::

   drop A -> ()

Discard the top element of the stack.


Function Application
####################

``.`` apply
------------
::

   x:* . -> x.

If ``x`` is a symbol, look up the value and call it if a function,
push onto the stack otherwise. If ``x`` is a function literal, call
``x``, if ``x`` is any other value, simply push ``x`` onto the stack.

``$`` swap and apply
---------------------
::

   f $ x y -> f. y x

Swap ``x`` and ``y`` and then apply ``f``.

Assignment
##########

``:`` set/print
---------------
::

   {Q | L } : x... -> ()

``:`` either takes a symbol or a list of symbols and binds them to the
corresponding values on the stack: ::

  xs> x:5; x;
  0: 5

  xs> ([`x`y]):3 5; x y;
  1: 5
  0: 3

If given a null, instead of a symbol, ``:`` will print out the value
to ``stdout``: ::

  xs> 0n:"Hello, World!"
  "Hello, World!"

``~`` peek set/print
--------------------
::

   {Q | L} : x... -> x...

``~`` binds a variable or multiple variables to the local context much
like ``:``, except the value is not popped off the stack: ::

  xs> x+x~5
  0: 10

  xs> ([`x`y])~2 3; x+y+ +.
  0: 10

Likewise, if given a null, ``~`` will print out the value(s) to ``stdout``: ::

  xs> 0n~5
  5
  0: 5
